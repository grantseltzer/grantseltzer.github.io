<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on GrantSeltzer</title>
    <link>https://grantseltzer.github.io/blog/</link>
    <description>Recent content in Blogs on GrantSeltzer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Feb 2020 03:32:37 +0000</lastBuildDate>
    
	<atom:link href="https://grantseltzer.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tracing Go Functions with eBPF Part 1</title>
      <link>https://grantseltzer.github.io/blog/tracing-go-functions-with-ebpf-part-1/</link>
      <pubDate>Fri, 14 Feb 2020 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/tracing-go-functions-with-ebpf-part-1/</guid>
      <description>eBPF makes you an omniscient gopher
eBPF is a virtual machine, similar in concept to the JVM, except it&amp;rsquo;s inside the Linux kernel. It lets you write C-like code, compile it, and load the byte code into the kernel. You can then attach hooks to your loaded eBPF program to trigger it to run. Those hooks could be things like system calls, kprobes, or uprobes.
There&amp;rsquo;s many use cases for eBPF.</description>
    </item>
    
    <item>
      <title>Using Karn for Seccomp Enforcement</title>
      <link>https://grantseltzer.github.io/blog/karn/</link>
      <pubDate>Wed, 11 Dec 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/karn/</guid>
      <description>me when someone turns off seccomp
Karn aims to provide for Linux what entitlements provide for iOS, or what pledge provides for OpenBSD. It does this by translating a high level set of intuitive &amp;lsquo;entitlements&amp;rsquo; into complex seccomp profiles.
For example, A developer using Karn can simply specify that their application needs to make network connections, or exec other processes and karn will handle granting it permission to do those things (and nothing else!</description>
    </item>
    
    <item>
      <title>Linux Procfs</title>
      <link>https://grantseltzer.github.io/blog/procfs/</link>
      <pubDate>Wed, 02 Oct 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/procfs/</guid>
      <description>I love the procfs because it provides an intuitive and easy to use interface for interacting with the kernel. In the same way you&amp;rsquo;d normally use the command line for exploring files, you can control and find out information about currently running processes. All without the need for system calls.
A procfs is mounted at /proc by default. If you go into /proc you&amp;rsquo;ll see something like this:</description>
    </item>
    
    <item>
      <title>Linux Overlayfs</title>
      <link>https://grantseltzer.github.io/blog/overlayfs/</link>
      <pubDate>Wed, 18 Sep 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/overlayfs/</guid>
      <description>Remember back to when your teacher in grade school would write on sheets of clear plastic, stack them, and display them with an overhead projector? That is exactly how overlayfs works&amp;hellip; except with filesystems.
Overlay filesystems allow you to take multiple directory trees and view them as if they were merged together. The added benefit is that changes in the merged view do not affect the underlying directories. There are many use cases for this, mostly related to containers, but more on that at the end.</description>
    </item>
    
    <item>
      <title>Debugging Go tests</title>
      <link>https://grantseltzer.github.io/blog/test-build-modes/</link>
      <pubDate>Thu, 15 Aug 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/test-build-modes/</guid>
      <description>This post discusses building go test binaries and walking through them with delve 
I recently was working on debugging a unit test I wrote in Go. I couldn&amp;rsquo;t figure out why one of my test cases was causing a runtime error that never happened when running my actual program. I was using a runtime directive so I suspected there may be some difference between doing a go test and a go run.</description>
    </item>
    
    <item>
      <title>Standardized Streams and Shells</title>
      <link>https://grantseltzer.github.io/blog/standardized-streams-and-shells/</link>
      <pubDate>Tue, 21 May 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/standardized-streams-and-shells/</guid>
      <description>In this post we discuss how standardized streams (stdin/stdout/stderr) work on Linux, especially related to shells. 
Every well known operating system has a concept of standardized streams. These consist of standard input, output, and error. As their name purports, they are the standard places for proccesses to read input, and send output. They&amp;rsquo;re a crucial concept that allows various running processes to easily communicate.
Standardized streams enable you to string together multiple commands with a pipe (|) in your shell like this:</description>
    </item>
    
    <item>
      <title>Using dynamic libraries in static Go binaries</title>
      <link>https://grantseltzer.github.io/blog/using-dynamic-libraries-in-static-go-binaries/</link>
      <pubDate>Tue, 09 Apr 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/using-dynamic-libraries-in-static-go-binaries/</guid>
      <description>This post highlights a linker directive in Go. It allows us to import functions from a dynamic library even when CGO is disabled. I use the example of a contribution I recently made to the net and runtime packages to demonstrate its use case. 
Go has many little known features that allow you to give instructions to the compiler, linker, and other parts of the toolchain using special comments. Dave Cheney wrote an excellent post on them here.</description>
    </item>
    
    <item>
      <title>The Beauty of io.Writer</title>
      <link>https://grantseltzer.github.io/blog/the-beauty-of-io-writer/</link>
      <pubDate>Thu, 04 Apr 2019 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/the-beauty-of-io-writer/</guid>
      <description>In this post we explore best practices of defining interfaces in Go. We use io.Writer to break down patterns and antipatterns. 
A perfect example of a properly designed Go interface is io.Writer:
type Writer interface { Write(p []byte) (n int, err error) }  It is short, simple, and powerful. The Write method takes a very generic slice of bytes and writes it to something.
In Rob Pike&amp;rsquo;s Go Proverbs talk he talks about how in Go, interfaces are not declared to be satisfied, they&amp;rsquo;re satisfied implicitly.</description>
    </item>
    
    <item>
      <title>Understanding cgroups</title>
      <link>https://grantseltzer.github.io/blog/understanding-cgroups/</link>
      <pubDate>Tue, 20 Nov 2018 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/understanding-cgroups/</guid>
      <description>This post will introduce you to cgroups. The goal is to give a comprehensive enough explanation of cgroups and subsystems to broadly understand what they accomplish and how. The major focus will be on the CPU cgroup. The second section and third section will explore using cgroups from the command line. 
Control groups (or cgroups) are a feature of the Linux kernel by which groups of processes can be monitored and have their resources limited.</description>
    </item>
    
    <item>
      <title>Dissecting Go Binaries</title>
      <link>https://grantseltzer.github.io/blog/dissecting-go-binaries/</link>
      <pubDate>Fri, 14 Sep 2018 03:32:37 +0000</pubDate>
      
      <guid>https://grantseltzer.github.io/blog/dissecting-go-binaries/</guid>
      <description>This post will introduce you to the basic concepts of disassembly and walk through writing a simple disassembler in Go. The goal is to make the whole concept of disassembly as accessible as possible and hopefully give you, the reader, a takeaway or two about how compiled Go binaries work. 
Assembly code cannot lie. By reading assembly we become as close as possible to knowing whatâ€™s being run on our computer chips.</description>
    </item>
    
  </channel>
</rss>