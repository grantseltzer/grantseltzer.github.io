<!DOCTYPE html>

    <head>

        <meta charset="utf-8">
        <meta name="generator" content="Hugo 0.92.2" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script data-goatcounter="https://grantpizza.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

        <style>

        body { margin: 0; }

        #title {
            font-family: "Open Sans", sans-serif;
            padding-top: 100px;
            margin-left: auto;
            margin-right: auto;
            margin-top: 0;
            margin-bottom: 0;
            font-size: 50px;
            border-top: solid;
        }

        #text-content {
            padding-left: 30px;
            float: center;
            width: 75%;
            font-family: "Open Sans", sans-serif;
            font-size: 20px;
            line-height: 40px;
        }

        pre code {
            padding: 1rem 1.5rem;
            border-radius: 4px;
            display: block;
            border: 3px solid white;
            color: black;
            line-height: 25px;
            overflow: scroll;
        }
        
        code {
            font-family: monospace;
            margin: 0 .2rem;
            font-size: 100%;
            background: #F1F1F1;
            border: 1px solid #d1d1d1;
            white-space: pre;
            overflow: scroll;
        }

        #topbar {
            position: fixed;
            border-top: solid;
            border-bottom: solid;
            border-bottom-width: 2px;
            border-bottom-style: ridge;
            width: 100%;
            opacity: 0.9;
            background-color: rgb(255, 255, 255);
        }

        #homelink {
            padding-top: 25px;
            font-size: 30px;
            font-style: italic;
            font-weight: bold;
            text-shadow: 1px 1px 1px grey;
            font-family: Arial, Helvetica, sans-serif;
        }

        @media (min-width: 1000px){
            #talk-content {
                display: block;
                text-align: center;
                font-family: "Open Sans", sans-serif;
                font-size: 20px;
            }
            img {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 70%;
                height: auto;
            }
        }

        @media (max-width: 999px) {
            img {
                display: block;
                margin-left: auto;
                margin-right: auto;
                width: 90%;
                height: auto;
            }
        }
        a { text-decoration: none; color: black; font-weight: bold; line-height: 1.3em; }
        a:hover { font-style: italic; border-bottom: 5px solid yellow }
        .copyright { padding-top: 50px; display: block; text-align: center; }

        </style>

    </head>

    <body>
        <div id="topbar">
            <a id="homelink" href="/">GSR</a>
        </div>

        <h1 id="title">Building Go Stack Traces from BPF</h1>
        <h4>November 15, 2023</h4>
        <div id="text-content">
        <p>In my posts from a few years ago I explored the idea of attaching bpf programs to Go functions via uprobes. The second post dived into how to extract values of parameters. This can be seen as part 3 of the series as i&rsquo;m going to demonstrate how to get a stack trace from bpf code.</p>
<p>The purpose of a stack trace is simple. When a function is called, we want to know the order of execution of every function/line that lead to the function invocation.</p>
<p>Take the following code as an example,</p>
<pre tabindex="0"><code>func stack_A() {
	stack_B()
}

func stack_B() {
	stack_C()
}

func stack_C() {
	print(&quot;hello!&quot;)
}

func main() {
    stack_A()
}
</code></pre><p>If we want a stack trace on invocations of <code>stack_C()</code> it would look something like this:</p>
<pre tabindex="0"><code>  &quot;main.stack_B (/home/vagrant/StackTraceExample/main.go:8)&quot;,
  &quot;main.stack_A (/home/vagrant/StackTraceExample/main.go:3)&quot;,
  &quot;main.main (/home/vagrant/StackTraceExample/main.go:45)&quot;
</code></pre><h3 id="stack-unwinding">Stack Unwinding</h3>
<p>The proccess we&rsquo;ll use for getting a basic stack trace is a simple and well documented set of steps. The basic principle is that we&rsquo;re going to collect program counters (locations of machine code) as we traverse through pointers that the Go compiler saves throughout the flow of execution.</p>
<p>When a function is called, a new &ldquo;stack frame&rdquo; is allocated. This basically means that a section of the program&rsquo;s stack is allocated to accomodate local variables in the new function.</p>
<p>When a new frame is allocated, the stack address of the previous frame is pushed onto the stack. After that, the return address is pushed onto the stack. The return address is the program counter in which the function will &lsquo;return&rsquo; to when the function exits.</p>

        
        
        </div>

        <span class="copyright">copyright 2018 - 2023</span>

    </body>
    
</html>